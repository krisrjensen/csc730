
Let's begin by setting the stage for the OptiGrid code, by analyzing the pseudocode set out by Hinneburg and Keim [2]. Then the structure of the code will be outlined, followed by a detailed analysis of each function and its purpose.\newline
% Compare this snippet from assignment%203/report/sections/discussion.tex:
\begin{tcolorbox}[breakable, title={$OptiGrid(dataset~D,~q,~min\_cut\_score)$}]
    %use numbers list
    \footnotesize     
    \begin{enumerate}        
        \item Determine a set of contracting projections P = \{$P_0$, . . ., $P_k$\}
        \item Calculate all projections of the dataset $D \to P_{0}(D)$, . . ., $P_{k}(D)$
        \item Initialize a list of cutting plances $BEST\_CUTS \leftarrow \emptyset, CUT \leftarrow \emptyset$
        \item FOR i=0 TO k Do
        \begin{enumerate}
            \item CUT $\leftarrow$ Determine best\_local\_cuts($P_i(D)$)
            \item CUT\_SCORE $\leftarrow$ score\_best\_local\_cuts($P_i(D)$)
            \item Insert all cutting planes with a score $\geq$ min\_cut\_score into $BEST\_CUTS$            
        \end{enumerate}
        END FOR
        \item IF $BEST\_CUT = \emptyset$ THEN RETURN $D$ as a cluster
        \item Determine the $q$ cutting planes with highest score from $BEST\_CUTS$ and delete the rest
        \item Construct a Multidimensional Grid $G$ defined by the cutting planes in $BEST\_CUTS$ and insert all data points $x \in D$ into $G$
        \item Determine clusters, i.e. determine the highly populated grid cells in G and add them to the set of cluster C
        \item REFINE(C)
        \item FOREACH Cluster $C_i \in C$ DO\newline
        OptiGrid($C_i$, q, min\_cut\_score)
    \end{enumerate}    
\end{tcolorbox}
\normalsize

\subsection{Functions of class OptiGrid}
\begin{enumerate}    
    \item $\_\_init\_\_$\newline
    {The $\_\_init\_\_$ functions acts as the class constructor. It initializes the class variables and sets the default values for the parameters. 
    The parameters include dataset dimension (d), number of cuts per iteration (q), the max cut score density of a plane ($max\_cut\_score$), noise level for dataset($noise\_level$), several parameters related to the kernel density estimation including bandwidth ($kde\_bandwidth$), grid ticks ($kde\_grid\_ticks$), sample size ($kde\_num\_samples$), tolerance ($kde\_atol$) and ($kde\_rtol$), and finally an argument for turning on or off output (verbose) . This function sets the initial conditions of the OptiGrid algorithm.}
    \item fit
    \item $\_iteration$
    \item $\_fill\_grid$
    \item $\_create\_cuts\_kde$
    \item $\_find\_best\_cuts$
    \item $\_find\_peaks\_distribution$
    \item $\_estimate\_distribution$
    \item $score\_samples$
    \item $\_score\_sample $
\end{enumerate}

\subsection{Functions of class GridLevel}
\begin{enumerate}    
    \item $\_\_init\_\_$
    \item $add\_subgrid$
    \item $get_sublevel$
\end{enumerate}


